// This code is auto-generated by genconversions.php -> DO NOT EDIT!!
//
// Don't call these functions directly!  Use TransferSamples(), see SoundFormatConversions.h

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define DEBUG_LEVEL 1
#include "SoundFormatRawConversions.h"

// macro to reduce the ugliness of using static_cast
#define cast(type,val) static_cast<type>(val)

// macro to directly access memory via the specified type
#define mem(type,var)       (*(type *)(var))
#define const_mem(type,var) (*(const type *)(var))

static void __CopyMemory_2(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	uint_t i;

	(void)ditherer;

	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		if (dst != src) memcpy(dst, src, nchannels * 2);
	}
}

static void __CopyMemory_3(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	uint_t i;

	(void)ditherer;

	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		if (dst != src) memcpy(dst, src, nchannels * 3);
	}
}

static void __CopyMemory_4(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	uint_t i;

	(void)ditherer;

	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		if (dst != src) memcpy(dst, src, nchannels * 4);
	}
}

static void __CopyMemory_8(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	uint_t i;

	(void)ditherer;

	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		if (dst != src) memcpy(dst, src, nchannels * 8);
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (LE) samples to 24bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitLE_to_24bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 2 - 2;
	dst += nchannels * 3 - 3;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 2;
	dstflen += nchannels * 3;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 2, dst -= 3) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[1]) << 24) + (cast(uint32_t, src[0]) << 16);
#endif
			// write sample bytes to destination
			dst[2] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
			dst[0] = cast(uint8_t, sval >> 8);
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (LE) samples to 32bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitLE_to_32bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 2 - 2;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 2;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 2, dst -= 4) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[1]) << 24) + (cast(uint32_t, src[0]) << 16);
#endif
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write integer sample directly
			mem(sint32_t, dst) = sval;
#else
			// write sample bytes to destination
			dst[3] = cast(uint8_t, sval >> 24);
			dst[2] = cast(uint8_t, sval >> 16);
			dst[1] = cast(uint8_t, sval >> 8);
			dst[0] = cast(uint8_t, sval);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (LE) samples to Float (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitLE_to_FloatLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, -31.0));
	sint32_t sval;
	float    dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 2 - 2;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 2;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 2, dst -= 4) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[1]) << 24) + (cast(uint32_t, src[0]) << 16);
#endif
			// convert integer sample to floating point sample (scale)
			dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write floating point sample directly
			mem(float, dst) = dval;
#else
			// write sample bytes to destination
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (LE) samples to Double (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitLE_to_DoubleLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, -31.0));
	sint32_t sval;
	double   dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint64_t *dvp = (uint64_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 2 - 2;
	dst += nchannels * 8 - 8;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 2;
	dstflen += nchannels * 8;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 2, dst -= 8) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[1]) << 24) + (cast(uint32_t, src[0]) << 16);
#endif
			// convert integer sample to floating point sample (scale)
			dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write floating point sample directly
			mem(double, dst) = dval;
#else
			// write sample bytes to destination
			dst[7] = cast(uint8_t, dvp[0] >> 56);
			dst[6] = cast(uint8_t, dvp[0] >> 48);
			dst[5] = cast(uint8_t, dvp[0] >> 40);
			dst[4] = cast(uint8_t, dvp[0] >> 32);
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (LE) samples to 16bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitLE_to_16bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 3;
	dstflen -= nchannels * 2;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 3, dst += 2) {
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[2]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[0]) << 8);
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 16);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write 16-bit integer sample directly
			mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
			// write sample bytes to destination
			dst[1] = cast(uint8_t, sval >> 24);
			dst[0] = cast(uint8_t, sval >> 16);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (LE) samples to 32bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitLE_to_32bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 3 - 3;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 3;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 3, dst -= 4) {
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[2]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[0]) << 8);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write integer sample directly
			mem(sint32_t, dst) = sval;
#else
			// write sample bytes to destination
			dst[3] = cast(uint8_t, sval >> 24);
			dst[2] = cast(uint8_t, sval >> 16);
			dst[1] = cast(uint8_t, sval >> 8);
			dst[0] = cast(uint8_t, sval);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (LE) samples to Float (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitLE_to_FloatLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, -31.0));
	sint32_t sval;
	float    dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 3 - 3;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 3;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 3, dst -= 4) {
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[2]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[0]) << 8);
			// convert integer sample to floating point sample (scale)
			dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write floating point sample directly
			mem(float, dst) = dval;
#else
			// write sample bytes to destination
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (LE) samples to Double (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitLE_to_DoubleLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, -31.0));
	sint32_t sval;
	double   dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint64_t *dvp = (uint64_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 3 - 3;
	dst += nchannels * 8 - 8;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 3;
	dstflen += nchannels * 8;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 3, dst -= 8) {
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[2]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[0]) << 8);
			// convert integer sample to floating point sample (scale)
			dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write floating point sample directly
			mem(double, dst) = dval;
#else
			// write sample bytes to destination
			dst[7] = cast(uint8_t, dvp[0] >> 56);
			dst[6] = cast(uint8_t, dvp[0] >> 48);
			dst[5] = cast(uint8_t, dvp[0] >> 40);
			dst[4] = cast(uint8_t, dvp[0] >> 32);
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (LE) samples to 16bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitLE_to_16bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 2;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 2) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read integer sample directly
			sval = const_mem(sint32_t, src);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 16);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write 16-bit integer sample directly
			mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
			// write sample bytes to destination
			dst[1] = cast(uint8_t, sval >> 24);
			dst[0] = cast(uint8_t, sval >> 16);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (LE) samples to 24bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitLE_to_24bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 3;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 3) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read integer sample directly
			sval = const_mem(sint32_t, src);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 8);
			// write sample bytes to destination
			dst[2] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
			dst[0] = cast(uint8_t, sval >> 8);
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (LE) samples to Float (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitLE_to_FloatLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, -31.0));
	sint32_t sval;
	float    dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 4 - 4;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 4;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 4, dst -= 4) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read integer sample directly
			sval = const_mem(sint32_t, src);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
			// convert integer sample to floating point sample (scale)
			dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write floating point sample directly
			mem(float, dst) = dval;
#else
			// write sample bytes to destination
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (LE) samples to Double (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitLE_to_DoubleLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, -31.0));
	sint32_t sval;
	double   dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint64_t *dvp = (uint64_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 4 - 4;
	dst += nchannels * 8 - 8;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 4;
	dstflen += nchannels * 8;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 4, dst -= 8) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read integer sample directly
			sval = const_mem(sint32_t, src);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
			// convert integer sample to floating point sample (scale)
			dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write floating point sample directly
			mem(double, dst) = dval;
#else
			// write sample bytes to destination
			dst[7] = cast(uint8_t, dvp[0] >> 56);
			dst[6] = cast(uint8_t, dvp[0] >> 48);
			dst[5] = cast(uint8_t, dvp[0] >> 40);
			dst[4] = cast(uint8_t, dvp[0] >> 32);
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (LE) samples to 16bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatLE_to_16bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, 31.0));
	float    sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 2;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 2) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read floating point sample directly
			sval = const_mem(float, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 16);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write 16-bit integer sample directly
			mem(sint16_t, dst) = cast(sint16_t, dval >> 16);
#else
			// write sample bytes to destination
			dst[1] = cast(uint8_t, dvp[0] >> 24);
			dst[0] = cast(uint8_t, dvp[0] >> 16);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (LE) samples to 24bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatLE_to_24bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, 31.0));
	float    sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 3;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 3) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read floating point sample directly
			sval = const_mem(float, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 8);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
			// write sample bytes to destination
			dst[2] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[0] = cast(uint8_t, dvp[0] >> 8);
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (LE) samples to 32bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatLE_to_32bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, 31.0));
	float    sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 4) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read floating point sample directly
			sval = const_mem(float, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write integer sample directly
			mem(sint32_t, dst) = dval;
#else
			// write sample bytes to destination
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (LE) samples to Double (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatLE_to_DoubleLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	float    sval;
	double   dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint64_t *dvp = (uint64_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 4 - 4;
	dst += nchannels * 8 - 8;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 4;
	dstflen += nchannels * 8;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 4, dst -= 8) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read floating point sample directly
			sval = const_mem(float, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
			// convert one type of floating point sample to another
			dval = cast(double, sval);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write floating point sample directly
			mem(double, dst) = dval;
#else
			// write sample bytes to destination
			dst[7] = cast(uint8_t, dvp[0] >> 56);
			dst[6] = cast(uint8_t, dvp[0] >> 48);
			dst[5] = cast(uint8_t, dvp[0] >> 40);
			dst[4] = cast(uint8_t, dvp[0] >> 32);
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (LE) samples to 16bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleLE_to_16bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, 31.0));
	double   sval;
	sint32_t dval;
	uint64_t *svp = (uint64_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 8;
	dstflen -= nchannels * 2;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 8, dst += 2) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read floating point sample directly
			sval = const_mem(double, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint64_t, src[7]) << 56) + (cast(uint64_t, src[6]) << 48) + (cast(uint64_t, src[5]) << 40) + (cast(uint64_t, src[4]) << 32) + (cast(uint64_t, src[3]) << 24) + (cast(uint64_t, src[2]) << 16) + (cast(uint64_t, src[1]) << 8) + (cast(uint64_t, src[0]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 16);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write 16-bit integer sample directly
			mem(sint16_t, dst) = cast(sint16_t, dval >> 16);
#else
			// write sample bytes to destination
			dst[1] = cast(uint8_t, dvp[0] >> 24);
			dst[0] = cast(uint8_t, dvp[0] >> 16);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (LE) samples to 24bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleLE_to_24bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, 31.0));
	double   sval;
	sint32_t dval;
	uint64_t *svp = (uint64_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 8;
	dstflen -= nchannels * 3;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 8, dst += 3) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read floating point sample directly
			sval = const_mem(double, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint64_t, src[7]) << 56) + (cast(uint64_t, src[6]) << 48) + (cast(uint64_t, src[5]) << 40) + (cast(uint64_t, src[4]) << 32) + (cast(uint64_t, src[3]) << 24) + (cast(uint64_t, src[2]) << 16) + (cast(uint64_t, src[1]) << 8) + (cast(uint64_t, src[0]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 8);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
			// write sample bytes to destination
			dst[2] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[0] = cast(uint8_t, dvp[0] >> 8);
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (LE) samples to 32bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleLE_to_32bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, 31.0));
	double   sval;
	sint32_t dval;
	uint64_t *svp = (uint64_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 8;
	dstflen -= nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 8, dst += 4) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read floating point sample directly
			sval = const_mem(double, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint64_t, src[7]) << 56) + (cast(uint64_t, src[6]) << 48) + (cast(uint64_t, src[5]) << 40) + (cast(uint64_t, src[4]) << 32) + (cast(uint64_t, src[3]) << 24) + (cast(uint64_t, src[2]) << 16) + (cast(uint64_t, src[1]) << 8) + (cast(uint64_t, src[0]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 0);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write integer sample directly
			mem(sint32_t, dst) = dval;
#else
			// write sample bytes to destination
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (LE) samples to Float (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleLE_to_FloatLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	double   sval;
	float    dval;
	uint64_t *svp = (uint64_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 8;
	dstflen -= nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 8, dst += 4) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read floating point sample directly
			sval = const_mem(double, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint64_t, src[7]) << 56) + (cast(uint64_t, src[6]) << 48) + (cast(uint64_t, src[5]) << 40) + (cast(uint64_t, src[4]) << 32) + (cast(uint64_t, src[3]) << 24) + (cast(uint64_t, src[2]) << 16) + (cast(uint64_t, src[1]) << 8) + (cast(uint64_t, src[0]));
#endif
			// convert one type of floating point sample to another
			dval = cast(float, sval);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write floating point sample directly
			mem(float, dst) = dval;
#else
			// write sample bytes to destination
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (LE) samples to 16bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitLE_to_16bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 2;
	dstflen -= nchannels * 2;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 2, dst += 2) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[1]) << 24) + (cast(uint32_t, src[0]) << 16);
#endif
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write 16-bit integer sample directly
			mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (LE) samples to 24bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitLE_to_24bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 2 - 2;
	dst += nchannels * 3 - 3;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 2;
	dstflen += nchannels * 3;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 2, dst -= 3) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[1]) << 24) + (cast(uint32_t, src[0]) << 16);
#endif
			// write sample bytes to destination
			dst[0] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
			dst[2] = cast(uint8_t, sval >> 8);
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (LE) samples to 32bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitLE_to_32bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 2 - 2;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 2;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 2, dst -= 4) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[1]) << 24) + (cast(uint32_t, src[0]) << 16);
#endif
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write integer sample directly
			mem(sint32_t, dst) = sval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
			dst[2] = cast(uint8_t, sval >> 8);
			dst[3] = cast(uint8_t, sval);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (LE) samples to Float (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitLE_to_FloatBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, -31.0));
	sint32_t sval;
	float    dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 2 - 2;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 2;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 2, dst -= 4) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[1]) << 24) + (cast(uint32_t, src[0]) << 16);
#endif
			// convert integer sample to floating point sample (scale)
			dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write floating point sample directly
			mem(float, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[2] = cast(uint8_t, dvp[0] >> 8);
			dst[3] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (LE) samples to Double (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitLE_to_DoubleBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, -31.0));
	sint32_t sval;
	double   dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint64_t *dvp = (uint64_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 2 - 2;
	dst += nchannels * 8 - 8;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 2;
	dstflen += nchannels * 8;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 2, dst -= 8) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[1]) << 24) + (cast(uint32_t, src[0]) << 16);
#endif
			// convert integer sample to floating point sample (scale)
			dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write floating point sample directly
			mem(double, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 56);
			dst[1] = cast(uint8_t, dvp[0] >> 48);
			dst[2] = cast(uint8_t, dvp[0] >> 40);
			dst[3] = cast(uint8_t, dvp[0] >> 32);
			dst[4] = cast(uint8_t, dvp[0] >> 24);
			dst[5] = cast(uint8_t, dvp[0] >> 16);
			dst[6] = cast(uint8_t, dvp[0] >> 8);
			dst[7] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (LE) samples to 16bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitLE_to_16bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 3;
	dstflen -= nchannels * 2;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 3, dst += 2) {
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[2]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[0]) << 8);
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 16);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write 16-bit integer sample directly
			mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (LE) samples to 24bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitLE_to_24bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 3;
	dstflen -= nchannels * 3;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 3, dst += 3) {
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[2]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[0]) << 8);
			// write sample bytes to destination
			dst[0] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
			dst[2] = cast(uint8_t, sval >> 8);
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (LE) samples to 32bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitLE_to_32bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 3 - 3;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 3;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 3, dst -= 4) {
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[2]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[0]) << 8);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write integer sample directly
			mem(sint32_t, dst) = sval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
			dst[2] = cast(uint8_t, sval >> 8);
			dst[3] = cast(uint8_t, sval);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (LE) samples to Float (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitLE_to_FloatBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, -31.0));
	sint32_t sval;
	float    dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 3 - 3;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 3;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 3, dst -= 4) {
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[2]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[0]) << 8);
			// convert integer sample to floating point sample (scale)
			dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write floating point sample directly
			mem(float, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[2] = cast(uint8_t, dvp[0] >> 8);
			dst[3] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (LE) samples to Double (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitLE_to_DoubleBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, -31.0));
	sint32_t sval;
	double   dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint64_t *dvp = (uint64_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 3 - 3;
	dst += nchannels * 8 - 8;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 3;
	dstflen += nchannels * 8;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 3, dst -= 8) {
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[2]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[0]) << 8);
			// convert integer sample to floating point sample (scale)
			dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write floating point sample directly
			mem(double, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 56);
			dst[1] = cast(uint8_t, dvp[0] >> 48);
			dst[2] = cast(uint8_t, dvp[0] >> 40);
			dst[3] = cast(uint8_t, dvp[0] >> 32);
			dst[4] = cast(uint8_t, dvp[0] >> 24);
			dst[5] = cast(uint8_t, dvp[0] >> 16);
			dst[6] = cast(uint8_t, dvp[0] >> 8);
			dst[7] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (LE) samples to 16bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitLE_to_16bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 2;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 2) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read integer sample directly
			sval = const_mem(sint32_t, src);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 16);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write 16-bit integer sample directly
			mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (LE) samples to 24bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitLE_to_24bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 3;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 3) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read integer sample directly
			sval = const_mem(sint32_t, src);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 8);
			// write sample bytes to destination
			dst[0] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
			dst[2] = cast(uint8_t, sval >> 8);
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (LE) samples to 32bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitLE_to_32bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 4) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read integer sample directly
			sval = const_mem(sint32_t, src);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write integer sample directly
			mem(sint32_t, dst) = sval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
			dst[2] = cast(uint8_t, sval >> 8);
			dst[3] = cast(uint8_t, sval);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (LE) samples to Float (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitLE_to_FloatBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, -31.0));
	sint32_t sval;
	float    dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 4 - 4;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 4;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 4, dst -= 4) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read integer sample directly
			sval = const_mem(sint32_t, src);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
			// convert integer sample to floating point sample (scale)
			dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write floating point sample directly
			mem(float, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[2] = cast(uint8_t, dvp[0] >> 8);
			dst[3] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (LE) samples to Double (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitLE_to_DoubleBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, -31.0));
	sint32_t sval;
	double   dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint64_t *dvp = (uint64_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 4 - 4;
	dst += nchannels * 8 - 8;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 4;
	dstflen += nchannels * 8;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 4, dst -= 8) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read integer sample directly
			sval = const_mem(sint32_t, src);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
			// convert integer sample to floating point sample (scale)
			dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write floating point sample directly
			mem(double, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 56);
			dst[1] = cast(uint8_t, dvp[0] >> 48);
			dst[2] = cast(uint8_t, dvp[0] >> 40);
			dst[3] = cast(uint8_t, dvp[0] >> 32);
			dst[4] = cast(uint8_t, dvp[0] >> 24);
			dst[5] = cast(uint8_t, dvp[0] >> 16);
			dst[6] = cast(uint8_t, dvp[0] >> 8);
			dst[7] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (LE) samples to 16bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatLE_to_16bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, 31.0));
	float    sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 2;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 2) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read floating point sample directly
			sval = const_mem(float, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 16);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write 16-bit integer sample directly
			mem(sint16_t, dst) = cast(sint16_t, dval >> 16);
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (LE) samples to 24bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatLE_to_24bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, 31.0));
	float    sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 3;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 3) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read floating point sample directly
			sval = const_mem(float, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 8);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[2] = cast(uint8_t, dvp[0] >> 8);
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (LE) samples to 32bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatLE_to_32bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, 31.0));
	float    sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 4) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read floating point sample directly
			sval = const_mem(float, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write integer sample directly
			mem(sint32_t, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[2] = cast(uint8_t, dvp[0] >> 8);
			dst[3] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (LE) samples to Float (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatLE_to_FloatBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	float    sval;
	float    dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 4) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read floating point sample directly
			sval = const_mem(float, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write floating point sample directly
			mem(float, dst) = sval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, svp[0] >> 24);
			dst[1] = cast(uint8_t, svp[0] >> 16);
			dst[2] = cast(uint8_t, svp[0] >> 8);
			dst[3] = cast(uint8_t, svp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (LE) samples to Double (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatLE_to_DoubleBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	float    sval;
	double   dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint64_t *dvp = (uint64_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 4 - 4;
	dst += nchannels * 8 - 8;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 4;
	dstflen += nchannels * 8;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 4, dst -= 8) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read floating point sample directly
			sval = const_mem(float, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
			// convert one type of floating point sample to another
			dval = cast(double, sval);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write floating point sample directly
			mem(double, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 56);
			dst[1] = cast(uint8_t, dvp[0] >> 48);
			dst[2] = cast(uint8_t, dvp[0] >> 40);
			dst[3] = cast(uint8_t, dvp[0] >> 32);
			dst[4] = cast(uint8_t, dvp[0] >> 24);
			dst[5] = cast(uint8_t, dvp[0] >> 16);
			dst[6] = cast(uint8_t, dvp[0] >> 8);
			dst[7] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (LE) samples to 16bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleLE_to_16bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, 31.0));
	double   sval;
	sint32_t dval;
	uint64_t *svp = (uint64_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 8;
	dstflen -= nchannels * 2;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 8, dst += 2) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read floating point sample directly
			sval = const_mem(double, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint64_t, src[7]) << 56) + (cast(uint64_t, src[6]) << 48) + (cast(uint64_t, src[5]) << 40) + (cast(uint64_t, src[4]) << 32) + (cast(uint64_t, src[3]) << 24) + (cast(uint64_t, src[2]) << 16) + (cast(uint64_t, src[1]) << 8) + (cast(uint64_t, src[0]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 16);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write 16-bit integer sample directly
			mem(sint16_t, dst) = cast(sint16_t, dval >> 16);
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (LE) samples to 24bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleLE_to_24bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, 31.0));
	double   sval;
	sint32_t dval;
	uint64_t *svp = (uint64_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 8;
	dstflen -= nchannels * 3;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 8, dst += 3) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read floating point sample directly
			sval = const_mem(double, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint64_t, src[7]) << 56) + (cast(uint64_t, src[6]) << 48) + (cast(uint64_t, src[5]) << 40) + (cast(uint64_t, src[4]) << 32) + (cast(uint64_t, src[3]) << 24) + (cast(uint64_t, src[2]) << 16) + (cast(uint64_t, src[1]) << 8) + (cast(uint64_t, src[0]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 8);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[2] = cast(uint8_t, dvp[0] >> 8);
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (LE) samples to 32bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleLE_to_32bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, 31.0));
	double   sval;
	sint32_t dval;
	uint64_t *svp = (uint64_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 8;
	dstflen -= nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 8, dst += 4) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read floating point sample directly
			sval = const_mem(double, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint64_t, src[7]) << 56) + (cast(uint64_t, src[6]) << 48) + (cast(uint64_t, src[5]) << 40) + (cast(uint64_t, src[4]) << 32) + (cast(uint64_t, src[3]) << 24) + (cast(uint64_t, src[2]) << 16) + (cast(uint64_t, src[1]) << 8) + (cast(uint64_t, src[0]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 0);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write integer sample directly
			mem(sint32_t, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[2] = cast(uint8_t, dvp[0] >> 8);
			dst[3] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (LE) samples to Float (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleLE_to_FloatBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	double   sval;
	float    dval;
	uint64_t *svp = (uint64_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 8;
	dstflen -= nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 8, dst += 4) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read floating point sample directly
			sval = const_mem(double, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint64_t, src[7]) << 56) + (cast(uint64_t, src[6]) << 48) + (cast(uint64_t, src[5]) << 40) + (cast(uint64_t, src[4]) << 32) + (cast(uint64_t, src[3]) << 24) + (cast(uint64_t, src[2]) << 16) + (cast(uint64_t, src[1]) << 8) + (cast(uint64_t, src[0]));
#endif
			// convert one type of floating point sample to another
			dval = cast(float, sval);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write floating point sample directly
			mem(float, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[2] = cast(uint8_t, dvp[0] >> 8);
			dst[3] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (LE) samples to Double (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleLE_to_DoubleBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	double   sval;
	double   dval;
	uint64_t *svp = (uint64_t *)&sval;
	uint64_t *dvp = (uint64_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 8;
	dstflen -= nchannels * 8;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 8, dst += 8) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// read floating point sample directly
			sval = const_mem(double, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint64_t, src[7]) << 56) + (cast(uint64_t, src[6]) << 48) + (cast(uint64_t, src[5]) << 40) + (cast(uint64_t, src[4]) << 32) + (cast(uint64_t, src[3]) << 24) + (cast(uint64_t, src[2]) << 16) + (cast(uint64_t, src[1]) << 8) + (cast(uint64_t, src[0]));
#endif
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write floating point sample directly
			mem(double, dst) = sval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, svp[0] >> 56);
			dst[1] = cast(uint8_t, svp[0] >> 48);
			dst[2] = cast(uint8_t, svp[0] >> 40);
			dst[3] = cast(uint8_t, svp[0] >> 32);
			dst[4] = cast(uint8_t, svp[0] >> 24);
			dst[5] = cast(uint8_t, svp[0] >> 16);
			dst[6] = cast(uint8_t, svp[0] >> 8);
			dst[7] = cast(uint8_t, svp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (BE) samples to 16bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitBE_to_16bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 2;
	dstflen -= nchannels * 2;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 2, dst += 2) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16);
#endif
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write 16-bit integer sample directly
			mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
			// write sample bytes to destination
			dst[1] = cast(uint8_t, sval >> 24);
			dst[0] = cast(uint8_t, sval >> 16);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (BE) samples to 24bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitBE_to_24bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 2 - 2;
	dst += nchannels * 3 - 3;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 2;
	dstflen += nchannels * 3;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 2, dst -= 3) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16);
#endif
			// write sample bytes to destination
			dst[2] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
			dst[0] = cast(uint8_t, sval >> 8);
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (BE) samples to 32bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitBE_to_32bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 2 - 2;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 2;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 2, dst -= 4) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16);
#endif
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write integer sample directly
			mem(sint32_t, dst) = sval;
#else
			// write sample bytes to destination
			dst[3] = cast(uint8_t, sval >> 24);
			dst[2] = cast(uint8_t, sval >> 16);
			dst[1] = cast(uint8_t, sval >> 8);
			dst[0] = cast(uint8_t, sval);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (BE) samples to Float (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitBE_to_FloatLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, -31.0));
	sint32_t sval;
	float    dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 2 - 2;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 2;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 2, dst -= 4) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16);
#endif
			// convert integer sample to floating point sample (scale)
			dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write floating point sample directly
			mem(float, dst) = dval;
#else
			// write sample bytes to destination
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (BE) samples to Double (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitBE_to_DoubleLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, -31.0));
	sint32_t sval;
	double   dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint64_t *dvp = (uint64_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 2 - 2;
	dst += nchannels * 8 - 8;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 2;
	dstflen += nchannels * 8;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 2, dst -= 8) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16);
#endif
			// convert integer sample to floating point sample (scale)
			dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write floating point sample directly
			mem(double, dst) = dval;
#else
			// write sample bytes to destination
			dst[7] = cast(uint8_t, dvp[0] >> 56);
			dst[6] = cast(uint8_t, dvp[0] >> 48);
			dst[5] = cast(uint8_t, dvp[0] >> 40);
			dst[4] = cast(uint8_t, dvp[0] >> 32);
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (BE) samples to 16bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitBE_to_16bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 3;
	dstflen -= nchannels * 2;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 3, dst += 2) {
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8);
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 16);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write 16-bit integer sample directly
			mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
			// write sample bytes to destination
			dst[1] = cast(uint8_t, sval >> 24);
			dst[0] = cast(uint8_t, sval >> 16);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (BE) samples to 24bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitBE_to_24bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 3;
	dstflen -= nchannels * 3;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 3, dst += 3) {
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8);
			// write sample bytes to destination
			dst[2] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
			dst[0] = cast(uint8_t, sval >> 8);
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (BE) samples to 32bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitBE_to_32bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 3 - 3;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 3;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 3, dst -= 4) {
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write integer sample directly
			mem(sint32_t, dst) = sval;
#else
			// write sample bytes to destination
			dst[3] = cast(uint8_t, sval >> 24);
			dst[2] = cast(uint8_t, sval >> 16);
			dst[1] = cast(uint8_t, sval >> 8);
			dst[0] = cast(uint8_t, sval);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (BE) samples to Float (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitBE_to_FloatLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, -31.0));
	sint32_t sval;
	float    dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 3 - 3;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 3;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 3, dst -= 4) {
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8);
			// convert integer sample to floating point sample (scale)
			dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write floating point sample directly
			mem(float, dst) = dval;
#else
			// write sample bytes to destination
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (BE) samples to Double (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitBE_to_DoubleLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, -31.0));
	sint32_t sval;
	double   dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint64_t *dvp = (uint64_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 3 - 3;
	dst += nchannels * 8 - 8;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 3;
	dstflen += nchannels * 8;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 3, dst -= 8) {
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8);
			// convert integer sample to floating point sample (scale)
			dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write floating point sample directly
			mem(double, dst) = dval;
#else
			// write sample bytes to destination
			dst[7] = cast(uint8_t, dvp[0] >> 56);
			dst[6] = cast(uint8_t, dvp[0] >> 48);
			dst[5] = cast(uint8_t, dvp[0] >> 40);
			dst[4] = cast(uint8_t, dvp[0] >> 32);
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (BE) samples to 16bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitBE_to_16bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 2;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 2) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read integer sample directly
			sval = const_mem(sint32_t, src);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 16);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write 16-bit integer sample directly
			mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
			// write sample bytes to destination
			dst[1] = cast(uint8_t, sval >> 24);
			dst[0] = cast(uint8_t, sval >> 16);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (BE) samples to 24bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitBE_to_24bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 3;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 3) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read integer sample directly
			sval = const_mem(sint32_t, src);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 8);
			// write sample bytes to destination
			dst[2] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
			dst[0] = cast(uint8_t, sval >> 8);
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (BE) samples to 32bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitBE_to_32bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 4) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read integer sample directly
			sval = const_mem(sint32_t, src);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write integer sample directly
			mem(sint32_t, dst) = sval;
#else
			// write sample bytes to destination
			dst[3] = cast(uint8_t, sval >> 24);
			dst[2] = cast(uint8_t, sval >> 16);
			dst[1] = cast(uint8_t, sval >> 8);
			dst[0] = cast(uint8_t, sval);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (BE) samples to Float (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitBE_to_FloatLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, -31.0));
	sint32_t sval;
	float    dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 4 - 4;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 4;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 4, dst -= 4) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read integer sample directly
			sval = const_mem(sint32_t, src);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
			// convert integer sample to floating point sample (scale)
			dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write floating point sample directly
			mem(float, dst) = dval;
#else
			// write sample bytes to destination
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (BE) samples to Double (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitBE_to_DoubleLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, -31.0));
	sint32_t sval;
	double   dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint64_t *dvp = (uint64_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 4 - 4;
	dst += nchannels * 8 - 8;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 4;
	dstflen += nchannels * 8;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 4, dst -= 8) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read integer sample directly
			sval = const_mem(sint32_t, src);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
			// convert integer sample to floating point sample (scale)
			dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write floating point sample directly
			mem(double, dst) = dval;
#else
			// write sample bytes to destination
			dst[7] = cast(uint8_t, dvp[0] >> 56);
			dst[6] = cast(uint8_t, dvp[0] >> 48);
			dst[5] = cast(uint8_t, dvp[0] >> 40);
			dst[4] = cast(uint8_t, dvp[0] >> 32);
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (BE) samples to 16bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatBE_to_16bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, 31.0));
	float    sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 2;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 2) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read floating point sample directly
			sval = const_mem(float, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 16);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write 16-bit integer sample directly
			mem(sint16_t, dst) = cast(sint16_t, dval >> 16);
#else
			// write sample bytes to destination
			dst[1] = cast(uint8_t, dvp[0] >> 24);
			dst[0] = cast(uint8_t, dvp[0] >> 16);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (BE) samples to 24bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatBE_to_24bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, 31.0));
	float    sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 3;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 3) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read floating point sample directly
			sval = const_mem(float, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 8);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
			// write sample bytes to destination
			dst[2] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[0] = cast(uint8_t, dvp[0] >> 8);
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (BE) samples to 32bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatBE_to_32bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, 31.0));
	float    sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 4) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read floating point sample directly
			sval = const_mem(float, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write integer sample directly
			mem(sint32_t, dst) = dval;
#else
			// write sample bytes to destination
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (BE) samples to Float (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatBE_to_FloatLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	float    sval;
	float    dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 4) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read floating point sample directly
			sval = const_mem(float, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write floating point sample directly
			mem(float, dst) = sval;
#else
			// write sample bytes to destination
			dst[3] = cast(uint8_t, svp[0] >> 24);
			dst[2] = cast(uint8_t, svp[0] >> 16);
			dst[1] = cast(uint8_t, svp[0] >> 8);
			dst[0] = cast(uint8_t, svp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (BE) samples to Double (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatBE_to_DoubleLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	float    sval;
	double   dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint64_t *dvp = (uint64_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 4 - 4;
	dst += nchannels * 8 - 8;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 4;
	dstflen += nchannels * 8;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 4, dst -= 8) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read floating point sample directly
			sval = const_mem(float, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
			// convert one type of floating point sample to another
			dval = cast(double, sval);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write floating point sample directly
			mem(double, dst) = dval;
#else
			// write sample bytes to destination
			dst[7] = cast(uint8_t, dvp[0] >> 56);
			dst[6] = cast(uint8_t, dvp[0] >> 48);
			dst[5] = cast(uint8_t, dvp[0] >> 40);
			dst[4] = cast(uint8_t, dvp[0] >> 32);
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (BE) samples to 16bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleBE_to_16bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, 31.0));
	double   sval;
	sint32_t dval;
	uint64_t *svp = (uint64_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 8;
	dstflen -= nchannels * 2;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 8, dst += 2) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read floating point sample directly
			sval = const_mem(double, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint64_t, src[0]) << 56) + (cast(uint64_t, src[1]) << 48) + (cast(uint64_t, src[2]) << 40) + (cast(uint64_t, src[3]) << 32) + (cast(uint64_t, src[4]) << 24) + (cast(uint64_t, src[5]) << 16) + (cast(uint64_t, src[6]) << 8) + (cast(uint64_t, src[7]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 16);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write 16-bit integer sample directly
			mem(sint16_t, dst) = cast(sint16_t, dval >> 16);
#else
			// write sample bytes to destination
			dst[1] = cast(uint8_t, dvp[0] >> 24);
			dst[0] = cast(uint8_t, dvp[0] >> 16);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (BE) samples to 24bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleBE_to_24bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, 31.0));
	double   sval;
	sint32_t dval;
	uint64_t *svp = (uint64_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 8;
	dstflen -= nchannels * 3;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 8, dst += 3) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read floating point sample directly
			sval = const_mem(double, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint64_t, src[0]) << 56) + (cast(uint64_t, src[1]) << 48) + (cast(uint64_t, src[2]) << 40) + (cast(uint64_t, src[3]) << 32) + (cast(uint64_t, src[4]) << 24) + (cast(uint64_t, src[5]) << 16) + (cast(uint64_t, src[6]) << 8) + (cast(uint64_t, src[7]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 8);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
			// write sample bytes to destination
			dst[2] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[0] = cast(uint8_t, dvp[0] >> 8);
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (BE) samples to 32bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleBE_to_32bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, 31.0));
	double   sval;
	sint32_t dval;
	uint64_t *svp = (uint64_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 8;
	dstflen -= nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 8, dst += 4) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read floating point sample directly
			sval = const_mem(double, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint64_t, src[0]) << 56) + (cast(uint64_t, src[1]) << 48) + (cast(uint64_t, src[2]) << 40) + (cast(uint64_t, src[3]) << 32) + (cast(uint64_t, src[4]) << 24) + (cast(uint64_t, src[5]) << 16) + (cast(uint64_t, src[6]) << 8) + (cast(uint64_t, src[7]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 0);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write integer sample directly
			mem(sint32_t, dst) = dval;
#else
			// write sample bytes to destination
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (BE) samples to Float (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleBE_to_FloatLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	double   sval;
	float    dval;
	uint64_t *svp = (uint64_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 8;
	dstflen -= nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 8, dst += 4) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read floating point sample directly
			sval = const_mem(double, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint64_t, src[0]) << 56) + (cast(uint64_t, src[1]) << 48) + (cast(uint64_t, src[2]) << 40) + (cast(uint64_t, src[3]) << 32) + (cast(uint64_t, src[4]) << 24) + (cast(uint64_t, src[5]) << 16) + (cast(uint64_t, src[6]) << 8) + (cast(uint64_t, src[7]));
#endif
			// convert one type of floating point sample to another
			dval = cast(float, sval);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write floating point sample directly
			mem(float, dst) = dval;
#else
			// write sample bytes to destination
			dst[3] = cast(uint8_t, dvp[0] >> 24);
			dst[2] = cast(uint8_t, dvp[0] >> 16);
			dst[1] = cast(uint8_t, dvp[0] >> 8);
			dst[0] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (BE) samples to Double (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleBE_to_DoubleLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	double   sval;
	double   dval;
	uint64_t *svp = (uint64_t *)&sval;
	uint64_t *dvp = (uint64_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 8;
	dstflen -= nchannels * 8;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 8, dst += 8) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read floating point sample directly
			sval = const_mem(double, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint64_t, src[0]) << 56) + (cast(uint64_t, src[1]) << 48) + (cast(uint64_t, src[2]) << 40) + (cast(uint64_t, src[3]) << 32) + (cast(uint64_t, src[4]) << 24) + (cast(uint64_t, src[5]) << 16) + (cast(uint64_t, src[6]) << 8) + (cast(uint64_t, src[7]));
#endif
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
			// write floating point sample directly
			mem(double, dst) = sval;
#else
			// write sample bytes to destination
			dst[7] = cast(uint8_t, svp[0] >> 56);
			dst[6] = cast(uint8_t, svp[0] >> 48);
			dst[5] = cast(uint8_t, svp[0] >> 40);
			dst[4] = cast(uint8_t, svp[0] >> 32);
			dst[3] = cast(uint8_t, svp[0] >> 24);
			dst[2] = cast(uint8_t, svp[0] >> 16);
			dst[1] = cast(uint8_t, svp[0] >> 8);
			dst[0] = cast(uint8_t, svp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (BE) samples to 24bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitBE_to_24bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 2 - 2;
	dst += nchannels * 3 - 3;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 2;
	dstflen += nchannels * 3;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 2, dst -= 3) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16);
#endif
			// write sample bytes to destination
			dst[0] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
			dst[2] = cast(uint8_t, sval >> 8);
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (BE) samples to 32bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitBE_to_32bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 2 - 2;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 2;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 2, dst -= 4) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16);
#endif
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write integer sample directly
			mem(sint32_t, dst) = sval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
			dst[2] = cast(uint8_t, sval >> 8);
			dst[3] = cast(uint8_t, sval);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (BE) samples to Float (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitBE_to_FloatBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, -31.0));
	sint32_t sval;
	float    dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 2 - 2;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 2;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 2, dst -= 4) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16);
#endif
			// convert integer sample to floating point sample (scale)
			dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write floating point sample directly
			mem(float, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[2] = cast(uint8_t, dvp[0] >> 8);
			dst[3] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (BE) samples to Double (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitBE_to_DoubleBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, -31.0));
	sint32_t sval;
	double   dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint64_t *dvp = (uint64_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 2 - 2;
	dst += nchannels * 8 - 8;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 2;
	dstflen += nchannels * 8;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 2, dst -= 8) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16);
#endif
			// convert integer sample to floating point sample (scale)
			dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write floating point sample directly
			mem(double, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 56);
			dst[1] = cast(uint8_t, dvp[0] >> 48);
			dst[2] = cast(uint8_t, dvp[0] >> 40);
			dst[3] = cast(uint8_t, dvp[0] >> 32);
			dst[4] = cast(uint8_t, dvp[0] >> 24);
			dst[5] = cast(uint8_t, dvp[0] >> 16);
			dst[6] = cast(uint8_t, dvp[0] >> 8);
			dst[7] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (BE) samples to 16bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitBE_to_16bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 3;
	dstflen -= nchannels * 2;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 3, dst += 2) {
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8);
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 16);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write 16-bit integer sample directly
			mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (BE) samples to 32bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitBE_to_32bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 3 - 3;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 3;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 3, dst -= 4) {
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write integer sample directly
			mem(sint32_t, dst) = sval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
			dst[2] = cast(uint8_t, sval >> 8);
			dst[3] = cast(uint8_t, sval);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (BE) samples to Float (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitBE_to_FloatBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, -31.0));
	sint32_t sval;
	float    dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 3 - 3;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 3;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 3, dst -= 4) {
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8);
			// convert integer sample to floating point sample (scale)
			dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write floating point sample directly
			mem(float, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[2] = cast(uint8_t, dvp[0] >> 8);
			dst[3] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (BE) samples to Double (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitBE_to_DoubleBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, -31.0));
	sint32_t sval;
	double   dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint64_t *dvp = (uint64_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 3 - 3;
	dst += nchannels * 8 - 8;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 3;
	dstflen += nchannels * 8;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 3, dst -= 8) {
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8);
			// convert integer sample to floating point sample (scale)
			dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write floating point sample directly
			mem(double, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 56);
			dst[1] = cast(uint8_t, dvp[0] >> 48);
			dst[2] = cast(uint8_t, dvp[0] >> 40);
			dst[3] = cast(uint8_t, dvp[0] >> 32);
			dst[4] = cast(uint8_t, dvp[0] >> 24);
			dst[5] = cast(uint8_t, dvp[0] >> 16);
			dst[6] = cast(uint8_t, dvp[0] >> 8);
			dst[7] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (BE) samples to 16bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitBE_to_16bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 2;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 2) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read integer sample directly
			sval = const_mem(sint32_t, src);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 16);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write 16-bit integer sample directly
			mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (BE) samples to 24bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitBE_to_24bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	sint32_t sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 3;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 3) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read integer sample directly
			sval = const_mem(sint32_t, src);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 8);
			// write sample bytes to destination
			dst[0] = cast(uint8_t, sval >> 24);
			dst[1] = cast(uint8_t, sval >> 16);
			dst[2] = cast(uint8_t, sval >> 8);
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (BE) samples to Float (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitBE_to_FloatBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, -31.0));
	sint32_t sval;
	float    dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 4 - 4;
	dst += nchannels * 4 - 4;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 4;
	dstflen += nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 4, dst -= 4) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read integer sample directly
			sval = const_mem(sint32_t, src);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
			// convert integer sample to floating point sample (scale)
			dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write floating point sample directly
			mem(float, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[2] = cast(uint8_t, dvp[0] >> 8);
			dst[3] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (BE) samples to Double (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitBE_to_DoubleBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, -31.0));
	sint32_t sval;
	double   dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint64_t *dvp = (uint64_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 4 - 4;
	dst += nchannels * 8 - 8;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 4;
	dstflen += nchannels * 8;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 4, dst -= 8) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read integer sample directly
			sval = const_mem(sint32_t, src);
#else
			// read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
			sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
			// convert integer sample to floating point sample (scale)
			dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write floating point sample directly
			mem(double, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 56);
			dst[1] = cast(uint8_t, dvp[0] >> 48);
			dst[2] = cast(uint8_t, dvp[0] >> 40);
			dst[3] = cast(uint8_t, dvp[0] >> 32);
			dst[4] = cast(uint8_t, dvp[0] >> 24);
			dst[5] = cast(uint8_t, dvp[0] >> 16);
			dst[6] = cast(uint8_t, dvp[0] >> 8);
			dst[7] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (BE) samples to 16bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatBE_to_16bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, 31.0));
	float    sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 2;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 2) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read floating point sample directly
			sval = const_mem(float, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 16);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write 16-bit integer sample directly
			mem(sint16_t, dst) = cast(sint16_t, dval >> 16);
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (BE) samples to 24bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatBE_to_24bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, 31.0));
	float    sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 3;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 3) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read floating point sample directly
			sval = const_mem(float, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 8);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[2] = cast(uint8_t, dvp[0] >> 8);
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (BE) samples to 32bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatBE_to_32bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const float factor = cast(float, pow(2.0, 31.0));
	float    sval;
	sint32_t dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 4;
	dstflen -= nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 4, dst += 4) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read floating point sample directly
			sval = const_mem(float, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write integer sample directly
			mem(sint32_t, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[2] = cast(uint8_t, dvp[0] >> 8);
			dst[3] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (BE) samples to Double (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatBE_to_DoubleBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	float    sval;
	double   dval;
	uint32_t *svp = (uint32_t *)&sval;
	uint64_t *dvp = (uint64_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// destination samples are bigger -> start from end of frame and work backwards
	src += nchannels * 4 - 4;
	dst += nchannels * 8 - 8;

	// adjust frame increments for effects of for-loop
	srcflen += nchannels * 4;
	dstflen += nchannels * 8;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src -= 4, dst -= 8) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read floating point sample directly
			sval = const_mem(float, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
			// convert one type of floating point sample to another
			dval = cast(double, sval);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write floating point sample directly
			mem(double, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 56);
			dst[1] = cast(uint8_t, dvp[0] >> 48);
			dst[2] = cast(uint8_t, dvp[0] >> 40);
			dst[3] = cast(uint8_t, dvp[0] >> 32);
			dst[4] = cast(uint8_t, dvp[0] >> 24);
			dst[5] = cast(uint8_t, dvp[0] >> 16);
			dst[6] = cast(uint8_t, dvp[0] >> 8);
			dst[7] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (BE) samples to 16bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleBE_to_16bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, 31.0));
	double   sval;
	sint32_t dval;
	uint64_t *svp = (uint64_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 8;
	dstflen -= nchannels * 2;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 8, dst += 2) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read floating point sample directly
			sval = const_mem(double, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint64_t, src[0]) << 56) + (cast(uint64_t, src[1]) << 48) + (cast(uint64_t, src[2]) << 40) + (cast(uint64_t, src[3]) << 32) + (cast(uint64_t, src[4]) << 24) + (cast(uint64_t, src[5]) << 16) + (cast(uint64_t, src[6]) << 8) + (cast(uint64_t, src[7]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 16);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write 16-bit integer sample directly
			mem(sint16_t, dst) = cast(sint16_t, dval >> 16);
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (BE) samples to 24bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleBE_to_24bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, 31.0));
	double   sval;
	sint32_t dval;
	uint64_t *svp = (uint64_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 8;
	dstflen -= nchannels * 3;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 8, dst += 3) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read floating point sample directly
			sval = const_mem(double, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint64_t, src[0]) << 56) + (cast(uint64_t, src[1]) << 48) + (cast(uint64_t, src[2]) << 40) + (cast(uint64_t, src[3]) << 32) + (cast(uint64_t, src[4]) << 24) + (cast(uint64_t, src[5]) << 16) + (cast(uint64_t, src[6]) << 8) + (cast(uint64_t, src[7]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 8);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[2] = cast(uint8_t, dvp[0] >> 8);
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (BE) samples to 32bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleBE_to_32bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	static const double factor = cast(double, pow(2.0, 31.0));
	double   sval;
	sint32_t dval;
	uint64_t *svp = (uint64_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 8;
	dstflen -= nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 8, dst += 4) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read floating point sample directly
			sval = const_mem(double, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint64_t, src[0]) << 56) + (cast(uint64_t, src[1]) << 48) + (cast(uint64_t, src[2]) << 40) + (cast(uint64_t, src[3]) << 32) + (cast(uint64_t, src[4]) << 24) + (cast(uint64_t, src[5]) << 16) + (cast(uint64_t, src[6]) << 8) + (cast(uint64_t, src[7]));
#endif
			// apply dither
			if (ditherer) ditherer->Dither(i, sval, 0);
			// convert floating point sample to integer sample (scale and limit)
			dval = cast(sint32_t, LIMIT(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write integer sample directly
			mem(sint32_t, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[2] = cast(uint8_t, dvp[0] >> 8);
			dst[3] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (BE) samples to Float (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleBE_to_FloatBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
	double   sval;
	float    dval;
	uint64_t *svp = (uint64_t *)&sval;
	uint32_t *dvp = (uint32_t *)&dval;
	uint_t i, j;

	(void)svp;
	(void)dvp;

	(void)ditherer;

	// adjust frame increments for effects of for-loop
	srcflen -= nchannels * 8;
	dstflen -= nchannels * 4;

	// process each frame
	for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen) {
		// process each channel
		for (j = 0; j < nchannels; j++, src += 8, dst += 4) {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// read floating point sample directly
			sval = const_mem(double, src);
#else
			// read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
			svp[0] = (cast(uint64_t, src[0]) << 56) + (cast(uint64_t, src[1]) << 48) + (cast(uint64_t, src[2]) << 40) + (cast(uint64_t, src[3]) << 32) + (cast(uint64_t, src[4]) << 24) + (cast(uint64_t, src[5]) << 16) + (cast(uint64_t, src[6]) << 8) + (cast(uint64_t, src[7]));
#endif
			// convert one type of floating point sample to another
			dval = cast(float, sval);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
			// write floating point sample directly
			mem(float, dst) = dval;
#else
			// write sample bytes to destination
			dst[0] = cast(uint8_t, dvp[0] >> 24);
			dst[1] = cast(uint8_t, dvp[0] >> 16);
			dst[2] = cast(uint8_t, dvp[0] >> 8);
			dst[3] = cast(uint8_t, dvp[0]);
#endif
		}
	}
}

const CONVERTSAMPLES SoundFormatConversions[2][2][SampleFormat_Count][SampleFormat_Count] = {
	{
		{
			// LE -> LE
			{
				//  (LE) ->  (LE)
				NULL /* no valid conversion */,
				//  (LE) -> 16bit (LE)
				NULL /* no valid conversion */,
				//  (LE) -> 24bit (LE)
				NULL /* no valid conversion */,
				//  (LE) -> 32bit (LE)
				NULL /* no valid conversion */,
				//  (LE) -> Float (LE)
				NULL /* no valid conversion */,
				//  (LE) -> Double (LE)
				NULL /* no valid conversion */,
			},
			{
				// 16bit (LE) ->  (LE)
				NULL /* no valid conversion */,
				// 16bit (LE) -> 16bit (LE)
				&__CopyMemory_2,
				// 16bit (LE) -> 24bit (LE)
				&__Convert_16bitLE_to_24bitLE,
				// 16bit (LE) -> 32bit (LE)
				&__Convert_16bitLE_to_32bitLE,
				// 16bit (LE) -> Float (LE)
				&__Convert_16bitLE_to_FloatLE,
				// 16bit (LE) -> Double (LE)
				&__Convert_16bitLE_to_DoubleLE,
			},
			{
				// 24bit (LE) ->  (LE)
				NULL /* no valid conversion */,
				// 24bit (LE) -> 16bit (LE)
				&__Convert_24bitLE_to_16bitLE,
				// 24bit (LE) -> 24bit (LE)
				&__CopyMemory_3,
				// 24bit (LE) -> 32bit (LE)
				&__Convert_24bitLE_to_32bitLE,
				// 24bit (LE) -> Float (LE)
				&__Convert_24bitLE_to_FloatLE,
				// 24bit (LE) -> Double (LE)
				&__Convert_24bitLE_to_DoubleLE,
			},
			{
				// 32bit (LE) ->  (LE)
				NULL /* no valid conversion */,
				// 32bit (LE) -> 16bit (LE)
				&__Convert_32bitLE_to_16bitLE,
				// 32bit (LE) -> 24bit (LE)
				&__Convert_32bitLE_to_24bitLE,
				// 32bit (LE) -> 32bit (LE)
				&__CopyMemory_4,
				// 32bit (LE) -> Float (LE)
				&__Convert_32bitLE_to_FloatLE,
				// 32bit (LE) -> Double (LE)
				&__Convert_32bitLE_to_DoubleLE,
			},
			{
				// Float (LE) ->  (LE)
				NULL /* no valid conversion */,
				// Float (LE) -> 16bit (LE)
				&__Convert_FloatLE_to_16bitLE,
				// Float (LE) -> 24bit (LE)
				&__Convert_FloatLE_to_24bitLE,
				// Float (LE) -> 32bit (LE)
				&__Convert_FloatLE_to_32bitLE,
				// Float (LE) -> Float (LE)
				&__CopyMemory_4,
				// Float (LE) -> Double (LE)
				&__Convert_FloatLE_to_DoubleLE,
			},
			{
				// Double (LE) ->  (LE)
				NULL /* no valid conversion */,
				// Double (LE) -> 16bit (LE)
				&__Convert_DoubleLE_to_16bitLE,
				// Double (LE) -> 24bit (LE)
				&__Convert_DoubleLE_to_24bitLE,
				// Double (LE) -> 32bit (LE)
				&__Convert_DoubleLE_to_32bitLE,
				// Double (LE) -> Float (LE)
				&__Convert_DoubleLE_to_FloatLE,
				// Double (LE) -> Double (LE)
				&__CopyMemory_8,
			},
		},
		{
			// LE -> BE
			{
				//  (LE) ->  (BE)
				NULL /* no valid conversion */,
				//  (LE) -> 16bit (BE)
				NULL /* no valid conversion */,
				//  (LE) -> 24bit (BE)
				NULL /* no valid conversion */,
				//  (LE) -> 32bit (BE)
				NULL /* no valid conversion */,
				//  (LE) -> Float (BE)
				NULL /* no valid conversion */,
				//  (LE) -> Double (BE)
				NULL /* no valid conversion */,
			},
			{
				// 16bit (LE) ->  (BE)
				NULL /* no valid conversion */,
				// 16bit (LE) -> 16bit (BE)
				&__Convert_16bitLE_to_16bitBE,
				// 16bit (LE) -> 24bit (BE)
				&__Convert_16bitLE_to_24bitBE,
				// 16bit (LE) -> 32bit (BE)
				&__Convert_16bitLE_to_32bitBE,
				// 16bit (LE) -> Float (BE)
				&__Convert_16bitLE_to_FloatBE,
				// 16bit (LE) -> Double (BE)
				&__Convert_16bitLE_to_DoubleBE,
			},
			{
				// 24bit (LE) ->  (BE)
				NULL /* no valid conversion */,
				// 24bit (LE) -> 16bit (BE)
				&__Convert_24bitLE_to_16bitBE,
				// 24bit (LE) -> 24bit (BE)
				&__Convert_24bitLE_to_24bitBE,
				// 24bit (LE) -> 32bit (BE)
				&__Convert_24bitLE_to_32bitBE,
				// 24bit (LE) -> Float (BE)
				&__Convert_24bitLE_to_FloatBE,
				// 24bit (LE) -> Double (BE)
				&__Convert_24bitLE_to_DoubleBE,
			},
			{
				// 32bit (LE) ->  (BE)
				NULL /* no valid conversion */,
				// 32bit (LE) -> 16bit (BE)
				&__Convert_32bitLE_to_16bitBE,
				// 32bit (LE) -> 24bit (BE)
				&__Convert_32bitLE_to_24bitBE,
				// 32bit (LE) -> 32bit (BE)
				&__Convert_32bitLE_to_32bitBE,
				// 32bit (LE) -> Float (BE)
				&__Convert_32bitLE_to_FloatBE,
				// 32bit (LE) -> Double (BE)
				&__Convert_32bitLE_to_DoubleBE,
			},
			{
				// Float (LE) ->  (BE)
				NULL /* no valid conversion */,
				// Float (LE) -> 16bit (BE)
				&__Convert_FloatLE_to_16bitBE,
				// Float (LE) -> 24bit (BE)
				&__Convert_FloatLE_to_24bitBE,
				// Float (LE) -> 32bit (BE)
				&__Convert_FloatLE_to_32bitBE,
				// Float (LE) -> Float (BE)
				&__Convert_FloatLE_to_FloatBE,
				// Float (LE) -> Double (BE)
				&__Convert_FloatLE_to_DoubleBE,
			},
			{
				// Double (LE) ->  (BE)
				NULL /* no valid conversion */,
				// Double (LE) -> 16bit (BE)
				&__Convert_DoubleLE_to_16bitBE,
				// Double (LE) -> 24bit (BE)
				&__Convert_DoubleLE_to_24bitBE,
				// Double (LE) -> 32bit (BE)
				&__Convert_DoubleLE_to_32bitBE,
				// Double (LE) -> Float (BE)
				&__Convert_DoubleLE_to_FloatBE,
				// Double (LE) -> Double (BE)
				&__Convert_DoubleLE_to_DoubleBE,
			},
		},
	},
	{
		{
			// BE -> LE
			{
				//  (BE) ->  (LE)
				NULL /* no valid conversion */,
				//  (BE) -> 16bit (LE)
				NULL /* no valid conversion */,
				//  (BE) -> 24bit (LE)
				NULL /* no valid conversion */,
				//  (BE) -> 32bit (LE)
				NULL /* no valid conversion */,
				//  (BE) -> Float (LE)
				NULL /* no valid conversion */,
				//  (BE) -> Double (LE)
				NULL /* no valid conversion */,
			},
			{
				// 16bit (BE) ->  (LE)
				NULL /* no valid conversion */,
				// 16bit (BE) -> 16bit (LE)
				&__Convert_16bitBE_to_16bitLE,
				// 16bit (BE) -> 24bit (LE)
				&__Convert_16bitBE_to_24bitLE,
				// 16bit (BE) -> 32bit (LE)
				&__Convert_16bitBE_to_32bitLE,
				// 16bit (BE) -> Float (LE)
				&__Convert_16bitBE_to_FloatLE,
				// 16bit (BE) -> Double (LE)
				&__Convert_16bitBE_to_DoubleLE,
			},
			{
				// 24bit (BE) ->  (LE)
				NULL /* no valid conversion */,
				// 24bit (BE) -> 16bit (LE)
				&__Convert_24bitBE_to_16bitLE,
				// 24bit (BE) -> 24bit (LE)
				&__Convert_24bitBE_to_24bitLE,
				// 24bit (BE) -> 32bit (LE)
				&__Convert_24bitBE_to_32bitLE,
				// 24bit (BE) -> Float (LE)
				&__Convert_24bitBE_to_FloatLE,
				// 24bit (BE) -> Double (LE)
				&__Convert_24bitBE_to_DoubleLE,
			},
			{
				// 32bit (BE) ->  (LE)
				NULL /* no valid conversion */,
				// 32bit (BE) -> 16bit (LE)
				&__Convert_32bitBE_to_16bitLE,
				// 32bit (BE) -> 24bit (LE)
				&__Convert_32bitBE_to_24bitLE,
				// 32bit (BE) -> 32bit (LE)
				&__Convert_32bitBE_to_32bitLE,
				// 32bit (BE) -> Float (LE)
				&__Convert_32bitBE_to_FloatLE,
				// 32bit (BE) -> Double (LE)
				&__Convert_32bitBE_to_DoubleLE,
			},
			{
				// Float (BE) ->  (LE)
				NULL /* no valid conversion */,
				// Float (BE) -> 16bit (LE)
				&__Convert_FloatBE_to_16bitLE,
				// Float (BE) -> 24bit (LE)
				&__Convert_FloatBE_to_24bitLE,
				// Float (BE) -> 32bit (LE)
				&__Convert_FloatBE_to_32bitLE,
				// Float (BE) -> Float (LE)
				&__Convert_FloatBE_to_FloatLE,
				// Float (BE) -> Double (LE)
				&__Convert_FloatBE_to_DoubleLE,
			},
			{
				// Double (BE) ->  (LE)
				NULL /* no valid conversion */,
				// Double (BE) -> 16bit (LE)
				&__Convert_DoubleBE_to_16bitLE,
				// Double (BE) -> 24bit (LE)
				&__Convert_DoubleBE_to_24bitLE,
				// Double (BE) -> 32bit (LE)
				&__Convert_DoubleBE_to_32bitLE,
				// Double (BE) -> Float (LE)
				&__Convert_DoubleBE_to_FloatLE,
				// Double (BE) -> Double (LE)
				&__Convert_DoubleBE_to_DoubleLE,
			},
		},
		{
			// BE -> BE
			{
				//  (BE) ->  (BE)
				NULL /* no valid conversion */,
				//  (BE) -> 16bit (BE)
				NULL /* no valid conversion */,
				//  (BE) -> 24bit (BE)
				NULL /* no valid conversion */,
				//  (BE) -> 32bit (BE)
				NULL /* no valid conversion */,
				//  (BE) -> Float (BE)
				NULL /* no valid conversion */,
				//  (BE) -> Double (BE)
				NULL /* no valid conversion */,
			},
			{
				// 16bit (BE) ->  (BE)
				NULL /* no valid conversion */,
				// 16bit (BE) -> 16bit (BE)
				&__CopyMemory_2,
				// 16bit (BE) -> 24bit (BE)
				&__Convert_16bitBE_to_24bitBE,
				// 16bit (BE) -> 32bit (BE)
				&__Convert_16bitBE_to_32bitBE,
				// 16bit (BE) -> Float (BE)
				&__Convert_16bitBE_to_FloatBE,
				// 16bit (BE) -> Double (BE)
				&__Convert_16bitBE_to_DoubleBE,
			},
			{
				// 24bit (BE) ->  (BE)
				NULL /* no valid conversion */,
				// 24bit (BE) -> 16bit (BE)
				&__Convert_24bitBE_to_16bitBE,
				// 24bit (BE) -> 24bit (BE)
				&__CopyMemory_3,
				// 24bit (BE) -> 32bit (BE)
				&__Convert_24bitBE_to_32bitBE,
				// 24bit (BE) -> Float (BE)
				&__Convert_24bitBE_to_FloatBE,
				// 24bit (BE) -> Double (BE)
				&__Convert_24bitBE_to_DoubleBE,
			},
			{
				// 32bit (BE) ->  (BE)
				NULL /* no valid conversion */,
				// 32bit (BE) -> 16bit (BE)
				&__Convert_32bitBE_to_16bitBE,
				// 32bit (BE) -> 24bit (BE)
				&__Convert_32bitBE_to_24bitBE,
				// 32bit (BE) -> 32bit (BE)
				&__CopyMemory_4,
				// 32bit (BE) -> Float (BE)
				&__Convert_32bitBE_to_FloatBE,
				// 32bit (BE) -> Double (BE)
				&__Convert_32bitBE_to_DoubleBE,
			},
			{
				// Float (BE) ->  (BE)
				NULL /* no valid conversion */,
				// Float (BE) -> 16bit (BE)
				&__Convert_FloatBE_to_16bitBE,
				// Float (BE) -> 24bit (BE)
				&__Convert_FloatBE_to_24bitBE,
				// Float (BE) -> 32bit (BE)
				&__Convert_FloatBE_to_32bitBE,
				// Float (BE) -> Float (BE)
				&__CopyMemory_4,
				// Float (BE) -> Double (BE)
				&__Convert_FloatBE_to_DoubleBE,
			},
			{
				// Double (BE) ->  (BE)
				NULL /* no valid conversion */,
				// Double (BE) -> 16bit (BE)
				&__Convert_DoubleBE_to_16bitBE,
				// Double (BE) -> 24bit (BE)
				&__Convert_DoubleBE_to_24bitBE,
				// Double (BE) -> 32bit (BE)
				&__Convert_DoubleBE_to_32bitBE,
				// Double (BE) -> Float (BE)
				&__Convert_DoubleBE_to_FloatBE,
				// Double (BE) -> Double (BE)
				&__CopyMemory_8,
			},
		},
	},
};
